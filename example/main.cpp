/**
 * @file main.cpp
 * @brief Demonstrates AES encryption and decryption in ECB, CBC, and CFB modes.
 *
 * Includes performance benchmarking and functional tests for AES algorithm.
 */


#include <iostream>
#include <vector>
#include <cstdint>
#include <sys/time.h>
#include <ctime>
#include "AesAlgo.hpp"

const unsigned int MICROSECONDS = 1000000;
unsigned long getMicroseconds()
{
    struct timeval tv;
    gettimeofday(&tv, NULL);
    return MICROSECONDS * tv.tv_sec + tv.tv_usec;
}

std::vector<uint8_t> getRandomPlain(unsigned int length)
{
    std::vector<uint8_t> plain(length);
    for (unsigned int i = 0; i < length; i++)
    {
        plain[i] = static_cast<uint8_t>(rand() % 256);
    }

    return plain;
}

/**
 * @brief Performs a speed test for AES encryption using ECB mode.
 * Measures performance with and without GF multiplication optimization.
 * @return 0 on success.
 */
int speedTest()
{
    const unsigned int MEGABYTE = 1024 * 1024 * sizeof(unsigned char);

    unsigned int megabytesCount = 10;
    unsigned int plainLength = megabytesCount * MEGABYTE;
    std::vector<uint8_t> key = {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f
    };

    std::cout << "Start speedtest" << std::endl;
    srand(std::time(nullptr));
    std::vector<uint8_t> plain = getRandomPlain(plainLength);

    {
        // Without GF multiplication optimization
        AesAlgo aes(true);
        unsigned long start = getMicroseconds();
        std::vector<uint8_t> out = aes.EncryptECB(plain, key);
        unsigned long delta = getMicroseconds() - start;
        double speed = (double)megabytesCount / delta * MICROSECONDS;
        printf("Without GF multiplication optimization: %.2f Mb/s time = %1ld\n", speed, delta);
    }
    {
        // with GF multiplication optimization
        AesAlgo aes(true);
        unsigned long start = getMicroseconds();
        std::vector<uint8_t> out = aes.EncryptECB(plain, key);
        unsigned long delta = getMicroseconds() - start;
        double speed = (double)megabytesCount / delta * MICROSECONDS;
        printf("With GF multiplication optimization:    %.2f Mb/s time = %1ld\n", speed, delta);
    }

    return 0;
}

// ----------- ECB Mode Functions ------------
/**
 * @brief Tests AES encryption of a single block in ECB mode.
 */
void EncryptOneBlockECB() {
    AesAlgo aes;

    std::vector<uint8_t> plain = {
        0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
        0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff
    };
    
    std::vector<uint8_t> key = {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f
    };
    
    std::vector<uint8_t> right = {
        0x69, 0xc4, 0xe0, 0xd8, 0x6a, 0x7b, 0x04, 0x30,
        0xd8, 0xcd, 0xb7, 0x80, 0x70, 0xb4, 0xc5, 0x5a
    };

    std::vector<uint8_t>out = aes.EncryptECB(plain, key);

    if (out == right) {
        std::cout << "Encryption successful!" << std::endl;
    } else {
        std::cout << "Mismatch in encrypted output!" << std::endl;
    }
}

/**
 * @brief Tests AES encryption of an unaligned block in ECB mode with padding enabled.
 */
void EncryptUnalignedBlockECB() {
    AesAlgo aes(false, true);

    std::vector<uint8_t> plain = {
        0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
        0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff,0x55
    };
    
    std::vector<uint8_t> key = {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f
    };
    
    std::vector<uint8_t> right = {
        0x69, 0xc4, 0xe0, 0xd8, 0x6a, 0x7b, 0x04, 0x30, 
        0xd8, 0xcd, 0xb7, 0x80, 0x70, 0xb4, 0xc5, 0x5a, 
        0xce, 0x06, 0xb8, 0x47, 0xa0, 0xc5, 0xbb, 0xfc, 
        0x54, 0x80, 0xc9, 0xee, 0x0c, 0xd0, 0xde, 0xc4
    };

    std::vector<uint8_t>out = aes.EncryptECB(plain, key);

    if (out == right) {
        std::cout << "Encryption successful!" << std::endl;
    } else {
        std::cout << "Mismatch in encrypted output!" << std::endl;
    }
}

/**
 * @brief Tests AES encryption and decryption of a single block in ECB mode.
 */
void EncryptDecryptOneBlockECB() {
    AesAlgo aes;

    std::vector<uint8_t> plain = {
        0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
        0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff
    };

    std::vector<uint8_t> key = {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
        0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
        0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f
    };

    std::vector<uint8_t>encryptOut = aes.EncryptECB(plain, key);
    std::vector<uint8_t>decryptOut = aes.DecryptECB(encryptOut, key);
    
    if (decryptOut == plain) {
        std::cout << "Encryption and Decryption successful!" << std::endl;
    } else {
        std::cout << "Mismatch in decrypted output!" << std::endl;
    }
}

/**
 * @brief Tests AES encryption of two blocks in ECB mode.
 */
void EncryptDecryptTwoBlockECB() {
    AesAlgo aes;
    
    std::vector<uint8_t> plain = {
        0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
        0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff,
        0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
        0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f
    };
    
    std::vector<uint8_t> key = {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f
    };
    
    std::vector<uint8_t> right = {
        0x69, 0xc4, 0xe0, 0xd8, 0x6a, 0x7b, 0x04, 0x30, 0xd8, 0xcd, 0xb7,
        0x80, 0x70, 0xb4, 0xc5, 0x5a, 0x07, 0xfe, 0xef, 0x74, 0xe1, 0xd5,
        0x03, 0x6e, 0x90, 0x0e, 0xee, 0x11, 0x8e, 0x94, 0x92, 0x93,
    };
    
    std::vector<uint8_t> out = aes.EncryptECB(plain, key);

    if (out == right) {
        std::cout << "Encryption of two blocks successful!" << std::endl;
    } else {
        std::cout << "Mismatch in encrypted output for two blocks!" << std::endl;
    }
}

// ----------- CBC Mode Functions ------------
/**
 * @brief Tests AES encryption of two blocks in CBC mode.
 */
void EncryptTwoBlockCBC() {
    AesAlgo aes;
    std::vector<uint8_t> plain = {
        0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
        0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff,
        0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
        0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff
    };
    std::vector<uint8_t> iv = {
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    };
    std::vector<uint8_t> key = {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f
    };
    std::vector<uint8_t> right = {
        0x1b, 0x87, 0x23, 0x78, 0x79, 0x5f, 0x4f, 0xfd,
        0x77, 0x28, 0x55, 0xfc, 0x87, 0xca, 0x96, 0x4d,
        0x4c, 0x5b, 0xca, 0x1c, 0x48, 0xcd, 0x88, 0x00,
        0x3a, 0x10, 0x52, 0x11, 0x88, 0x12, 0x5e, 0x00
    };

    std::vector<uint8_t> out = aes.EncryptCBC(plain, key, iv);
    if (out == right) {
        std::cout << "CBC Encryption successful!" << std::endl;
    } else {
        std::cout << "Mismatch in CBC encrypted output!" << std::endl;
    }
}

/**
 * @brief Tests AES decryption of two blocks in CBC mode.
 */
void DecryptTwoBlockCBC() {
    
    AesAlgo aes;
    
    std::vector<uint8_t> encrypted = {
        0x1b, 0x87, 0x23, 0x78, 0x79, 0x5f, 0x4f, 0xfd, 0x77, 0x28, 0x55,
        0xfc, 0x87, 0xca, 0x96, 0x4d, 0x4c, 0x5b, 0xca, 0x1c, 0x48, 0xcd,
        0x88, 0x00, 0x3a, 0x10, 0x52, 0x11, 0x88, 0x12, 0x5e, 0x00
    };
    
    std::vector<uint8_t> iv = {
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff
    };
    
    std::vector<uint8_t> key = {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05,
        0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,
        0x0c, 0x0d, 0x0e, 0x0f
    };
    
    std::vector<uint8_t> right = {
        0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa,
        0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55,
        0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff
    };
    
    std::vector<uint8_t> out = aes.DecryptCBC(encrypted, key, iv);
    
    if (out == right) {
        std::cout << "CBC Decryption successful!" << std::endl;
    } else {
        std::cout << "Mismatch in CBC decrypted output!" << std::endl;
    }
}


// ----------- CFB Mode Functions ------------
/**
 * @brief Tests AES encryption of two blocks in CFB mode.
 */
void EncryptTwoBlocksCFB() {
    
    AesAlgo aes;
    std::vector<uint8_t> plain = {
        0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa,
        0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55,
        0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff
    };

    std::vector<uint8_t> iv = {
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff
    };
    
    std::vector<uint8_t> key = {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05,
        0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,
        0x0c, 0x0d, 0x0e, 0x0f
    };
    
    std::vector<uint8_t> right = {
        0x3c, 0x55, 0x3d, 0x01, 0x8a, 0x52, 0xe4, 0x54, 0xec, 0x4e, 0x08,
        0x22, 0xc2, 0x8d, 0x55, 0xec, 0xe3, 0x5a, 0x40, 0xab, 0x30, 0x29,
        0xf3, 0x0c, 0xe1, 0xdb, 0x30, 0x6c, 0xa1, 0x05, 0xcb, 0xa9
    };
    
    std::vector<uint8_t> out = aes.EncryptCFB(plain, key, iv);
    if (out == right) {
        std::cout << "CFB Encryption successful!" << std::endl;
    } else {
        std::cout << "Mismatch in CFB encrypted output!" << std::endl;
    }
}

/**
 * @brief Tests AES decryption of two blocks in CFB mode.
 */
void DecryptTwoBlocksCFB() {
    AesAlgo aes;
    std::vector<unsigned char> encrypted = {
        0x3c, 0x55, 0x3d, 0x01, 0x8a, 0x52, 0xe4, 0x54, 0xec, 0x4e, 0x08,
        0x22, 0xc2, 0x8d, 0x55, 0xec, 0xe3, 0x5a, 0x40, 0xab, 0x30, 0x29,
        0xf3, 0x0c, 0xe1, 0xdb, 0x30, 0x6c, 0xa1, 0x05, 0xcb, 0xa9
    };
    
    std::vector<unsigned char> iv = {
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff
    };
    
    std::vector<unsigned char> key = {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05,
        0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,
        0x0c, 0x0d, 0x0e, 0x0f
    };
    
    std::vector<unsigned char> right = {
        0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa,
        0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55,
        0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff
    };

    std::vector<unsigned char> out = aes.DecryptCFB(encrypted, key, iv);
    if (out == right) {
        std::cout << "CFB Decryption successful!" << std::endl;
    } else {
        std::cout << "Mismatch in CFB decrypted output!" << std::endl;
    }
}


/**
 * @brief Entry point of the program.
 * Executes all AES test functions and performance benchmark.
 * @param argc Argument count.
 * @param argv Argument values.
 * @return 0 on success.
 */
int main(int argc, char **argv)
{

/**
 * @brief Tests AES encryption of a single block in ECB mode.
 */
    EncryptOneBlockECB();
/**
 * @brief Tests AES encryption of an unaligned block in ECB mode with padding enabled.
 */
    EncryptUnalignedBlockECB();

/**
 * @brief Tests AES encryption and decryption of a single block in ECB mode.
 */
    EncryptDecryptOneBlockECB();
/**
 * @brief Tests AES encryption of two blocks in ECB mode.
 */
    EncryptDecryptTwoBlockECB();

/**
 * @brief Tests AES encryption of two blocks in CBC mode.
 */
    EncryptTwoBlockCBC();
/**
 * @brief Tests AES decryption of two blocks in CBC mode.
 */
    DecryptTwoBlockCBC();

/**
 * @brief Tests AES encryption of two blocks in CFB mode.
 */
    EncryptTwoBlocksCFB();
/**
 * @brief Tests AES decryption of two blocks in CFB mode.
 */
    DecryptTwoBlocksCFB();
 
/**
 * @brief Performs a speed test for AES encryption using ECB mode.
 * Measures performance with and without GF multiplication optimization.
 * @return 0 on success.
 */
    speedTest();
    
    return 0;
}
